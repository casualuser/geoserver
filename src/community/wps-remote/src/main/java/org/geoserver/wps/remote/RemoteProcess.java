/* (c) 2014 Open Source Geospatial Foundation - all rights reserved
 * (c) 2001 - 2013 OpenPlans
 * This code is licensed under the GPL 2.0 license, available at the root
 * application directory.
 */
package org.geoserver.wps.remote;

import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.geotools.process.Process;
import org.geotools.process.ProcessException;
import org.geotools.util.logging.Logging;
import org.opengis.feature.type.Name;
import org.opengis.util.ProgressListener;

/**
 * Stub for the remote processes generated at run-time by the {@link RemoteProcessFactory} upon a {@link RemoteProcessClient} registration request.
 * 
 * @author Alessio Fabiani, GeoSolutions
 * 
 */
public class RemoteProcess implements Process, RemoteProcessClientListener {

    /** The LOGGER. */
    private static final Logger LOGGER = Logging.getLogger(RemoteProcess.class);

    /** The Process Name; declared by the remote service */
    private Name name;

    /** The {@link RemoteProcessClient} */
    private RemoteProcessClient remoteClient;

    /** A generic kvp map containing client specific implementation properties */
    private Map<String, Object> metadata;

    /** The Process Outputs; declared by the remote service */
    private Map<String, Object> outputs;

    /** Whether the Process is still running or not */
    private boolean running;

    /**
     * A Process ID generated by the {@link RemoteProcessClient}; this is used to uniquely identify the remote service sending commands and messages
     * to this {@link RemoteProcess} instance
     */
    private String pid;

    /** The progess listrener. */
    private ProgressListener listener;

    /** Whether the remote service raised and exception or not. This property contains the cause and is instantiated by the {@link RemoteProcessClient} */
    private Exception exception;

    /**
     * Constructs a new stub for the {@link RemoteProcess} execution. Metadata is a kvp map containing specific properties of the
     * {@link RemoteProcessClient} instance
     * 
     * @param name
     * @param remoteClient
     * @param metadata
     */
    public RemoteProcess(Name name, RemoteProcessClient remoteClient, Map<String, Object> metadata) {
        this.name = name;
        this.remoteClient = remoteClient;
        this.metadata = metadata;
    }

    @Override
    public Map<String, Object> execute(Map<String, Object> input, ProgressListener monitor) {

        try {
            // Generate a unique Process ID
            pid = remoteClient.execute(name, input, metadata, monitor);
            LOGGER.fine("Starting the execution of Remote Process with pId [" + pid + "]");
            listener = monitor;
            running = pid != null;
            if (running) {
                remoteClient.registerProcessClientListener(this);
                while (running && outputs == null && exception == null && !listener.isCanceled()) {
                    Thread.sleep(remoteClient.getConfiguration()
                            .getRemoteProcessStubCycleSleepTime());
                }
            }
            LOGGER.fine("Stopping the execution of Remote Process with pId [" + pid + "]");
        } catch (Exception e) {
            listener.exceptionOccurred(e);
            LOGGER.log(Level.SEVERE,
                    "The Remote Process with pId [" + pid + "] rasied an Exeption", e);
            throw new ProcessException(e);
        } finally {
            remoteClient.deregisterProcessClientListener(this);
        }

        if (exception != null) {
            LOGGER.log(Level.SEVERE, "The Remote Service associated to the Process with pId ["
                    + pid + "] rasied an Exeption", exception);
            throw new ProcessException(exception);
        }

        return outputs;
    }

    /**
     * @return the running
     */
    public boolean isRunning() {
        return running;
    }

    /**
     * @param running the running to set
     */
    public void setRunning(boolean running) {
        this.running = running;
    }

    /**
     * @return the outputs
     */
    public Map<String, Object> getOutputs() {
        return outputs;
    }

    /**
     * @param outputs the outputs to set
     */
    public void setOutputs(Map<String, Object> outputs) {
        this.outputs = outputs;
    }

    @Override
    public void progress(final String pId, final Double progress) {
        if (pId.equals(pid)) {
            listener.progress(progress.floatValue());
        }
    }

    @Override
    public void complete(String pId, Object outputs) {
        if (pId.equals(pid)) {
            listener.complete();
            this.outputs = (Map<String, Object>) outputs;
            running = false;
        }
    }

    @Override
    public void exceptionOccurred(final String pId, Exception cause, Map<String, Object> metadata) {
        if (pId != null && pId.equals(pid)) {
            listener.exceptionOccurred(cause);
            exception = cause;
            running = false;
        } else if (metadata != null) {
            boolean metadataIsEqual = true;

            for (Entry<String, Object> entry : metadata.entrySet()) {
                if (!this.metadata.containsKey(entry.getKey())
                        || this.metadata.get(entry.getKey()) != entry.getValue()) {
                    metadataIsEqual = false;
                    break;
                }
            }

            if (metadataIsEqual) {
                listener.exceptionOccurred(cause);
                exception = cause;
                running = false;
            }
        }
    }

}
